State 67 conflicts: 4 reduce/reduce
State 68 conflicts: 4 reduce/reduce
State 71 conflicts: 4 reduce/reduce
State 72 conflicts: 4 reduce/reduce


Grammar

    0 $accept: stmts $end

    1 stmts: stmts stmt
    2      | stmt

    3 stmt: expr SEMICOLON
    4     | LBRACE stmts RBRACE
    5     | const_dec_stmt
    6     | var_dec_stmt
    7     | assign_stmt
    8     | while_stmt
    9     | if_stmt
   10     | repeat_until_stmt
   11     | for_stmt
   12     | switch_stmt
   13     | function
   14     | RETURN ret_val SEMICOLON
   15     | BREAK SEMICOLON
   16     | CONTINUE SEMICOLON
   17     | PRINT LPAREN STRING RPAREN SEMICOLON

   18 ret_val: value
   19        | /* empty */

   20 value: expr
   21      | STRING_VAL
   22      | CHAR_VAL
   23      | INT_VAL
   24      | FLOAT_VAL
   25      | TRUE_VAL
   26      | FALSE_VAL

   27 expr: LPAREN expr RPAREN
   28     | bool_expr
   29     | arithmetic_expr

   30 bool_expr: expr EQUAL arithmetic_expr
   31          | expr NE arithmetic_expr
   32          | expr GREATER arithmetic_expr
   33          | expr LESS arithmetic_expr
   34          | expr GE arithmetic_expr
   35          | expr LE arithmetic_expr
   36          | expr AND expr
   37          | expr OR arithmetic_expr
   38          | NOT expr
   39          | TRUE_VAL
   40          | FALSE_VAL

   41 arithmetic_expr: binary_expr
   42                | unary_expr

   43 unary_expr: IDENTIFIER INC
   44           | IDENTIFIER DEC

   45 binary_expr: term
   46            | binary_expr PLUS term
   47            | binary_expr MINUS term

   48 term: factor
   49     | term MULT factor
   50     | term DIV factor
   51     | term MOD factor

   52 factor: INT_VAL
   53       | FLOAT_VAL
   54       | factor EXP factor
   55       | function_call
   56       | IDENTIFIER

   57 function_call: IDENTIFIER LPAREN RPAREN
   58              | IDENTIFIER LPAREN call_params RPAREN

   59 call_params: call_params COMMA value
   60            | value

   61 constant: INT_VAL
   62         | FLOAT_VAL
   63         | STRING_VAL
   64         | CHAR_VAL
   65         | TRUE_VAL
   66         | FALSE_VAL

   67 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant SEMICOLON

   68 var_dec_stmt: type IDENTIFIER SEMICOLON
   69             | type IDENTIFIER ASSIGN value SEMICOLON

   70 assign_stmt: IDENTIFIER ASSIGN value SEMICOLON
   71            | IDENTIFIER DIV_EQ value SEMICOLON
   72            | IDENTIFIER MULT_EQ value SEMICOLON
   73            | IDENTIFIER PLUS_EQ value SEMICOLON
   74            | IDENTIFIER MINUS_EQ value SEMICOLON

   75 while_stmt: WHILE expr LBRACE stmts RBRACE

   76 if_stmt: IF expr LBRACE stmts RBRACE
   77        | IF expr LBRACE stmts RBRACE ELSE LBRACE stmts RBRACE

   78 repeat_until_stmt: REPEAT LBRACE stmts RBRACE UNTIL expr SEMICOLON

   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE
   80         | FOR LPAREN assign_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE

   81 switch_stmt: SWITCH expr LBRACE case_stmts RBRACE

   82 case_stmts: case_stmts case_stmt
   83           | case_stmt

   84 case_stmt: CASE value COLON stmts
   85          | DEFAULT COLON stmts

   86 type: INT
   87     | FLOAT
   88     | CHAR
   89     | STRING
   90     | BOOL

   91 function: function_prototype LBRACE stmts RBRACE

   92 function_prototype: VOID IDENTIFIER LPAREN params RPAREN
   93                   | VOID IDENTIFIER LPAREN RPAREN
   94                   | type IDENTIFIER LPAREN params RPAREN
   95                   | type IDENTIFIER LPAREN RPAREN

   96 params: param
   97       | params COMMA param

   98 $@1: /* empty */

   99 param: type IDENTIFIER $@1 type IDENTIFIER ASSIGN constant


Terminals, with rules where they appear

$end (0) 0
error (256)
INT (258) 86
FLOAT (259) 87
CHAR (260) 88
BOOL (261) 90
STRING (262) 17 89
INT_VAL (263) 23 52 61
FLOAT_VAL (264) 24 53 62
CHAR_VAL (265) 22 64
STRING_VAL (266) 21 63
TRUE_VAL (267) 25 39 65
FALSE_VAL (268) 26 40 66
IDENTIFIER (269) 43 44 56 57 58 67 68 69 70 71 72 73 74 92 93 94 95
    99
CONST (270) 67
SEMICOLON (271) 3 14 15 16 17 67 68 69 70 71 72 73 74 78 79 80
COMMA (272) 59 97
LBRACE (273) 4 75 76 77 78 79 80 81 91
RBRACE (274) 4 75 76 77 78 79 80 81 91
LPAREN (275) 17 27 57 58 79 80 92 93 94 95
RPAREN (276) 17 27 57 58 79 80 92 93 94 95
BREAK (277) 15
CONTINUE (278) 16
WHILE (279) 75
FOR (280) 79 80
SWITCH (281) 81
CASE (282) 84
DEFAULT (283) 85
COLON (284) 84 85
IF (285) 76 77
ELSE (286) 77
REPEAT (287) 78
UNTIL (288) 78
LE (289) 35
GE (290) 34
NE (291) 31
EQUAL (292) 30
LESS (293) 33
GREATER (294) 32
MINUS (295) 47
PLUS (296) 46
MOD (297) 51
DIV (298) 50
MULT (299) 49
EXP (300) 54
NOT (301) 38
OR (302) 37
AND (303) 36
ASSIGN (304) 67 69 70 99
DIV_EQ (305) 71
PLUS_EQ (306) 73
MINUS_EQ (307) 74
MULT_EQ (308) 72
INC (309) 43
DEC (310) 44
VOID (311) 92 93
RETURN (312) 14
PRINT (313) 17


Nonterminals, with rules where they appear

$accept (59)
    on left: 0
stmts (60)
    on left: 1 2, on right: 0 1 4 75 76 77 78 79 80 84 85 91
stmt (61)
    on left: 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17, on right: 1 2
ret_val (62)
    on left: 18 19, on right: 14
value (63)
    on left: 20 21 22 23 24 25 26, on right: 18 59 60 69 70 71 72 73
    74 84
expr (64)
    on left: 27 28 29, on right: 3 20 27 30 31 32 33 34 35 36 37 38
    75 76 77 78 79 80 81
bool_expr (65)
    on left: 30 31 32 33 34 35 36 37 38 39 40, on right: 28
arithmetic_expr (66)
    on left: 41 42, on right: 29 30 31 32 33 34 35 37
unary_expr (67)
    on left: 43 44, on right: 42
binary_expr (68)
    on left: 45 46 47, on right: 41 46 47
term (69)
    on left: 48 49 50 51, on right: 45 46 47 49 50 51
factor (70)
    on left: 52 53 54 55 56, on right: 48 49 50 51 54
function_call (71)
    on left: 57 58, on right: 55
call_params (72)
    on left: 59 60, on right: 58 59
constant (73)
    on left: 61 62 63 64 65 66, on right: 67 99
const_dec_stmt (74)
    on left: 67, on right: 5
var_dec_stmt (75)
    on left: 68 69, on right: 6 79
assign_stmt (76)
    on left: 70 71 72 73 74, on right: 7 80
while_stmt (77)
    on left: 75, on right: 8
if_stmt (78)
    on left: 76 77, on right: 9
repeat_until_stmt (79)
    on left: 78, on right: 10
for_stmt (80)
    on left: 79 80, on right: 11
switch_stmt (81)
    on left: 81, on right: 12
case_stmts (82)
    on left: 82 83, on right: 81 82
case_stmt (83)
    on left: 84 85, on right: 82 83
type (84)
    on left: 86 87 88 89 90, on right: 67 68 69 94 95 99
function (85)
    on left: 91, on right: 13
function_prototype (86)
    on left: 92 93 94 95, on right: 91
params (87)
    on left: 96 97, on right: 92 94 97
param (88)
    on left: 99, on right: 96 97
$@1 (89)
    on left: 98, on right: 99


state 0

    0 $accept: . stmts $end

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 25
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 1

   86 type: INT .

    $default  reduce using rule 86 (type)


state 2

   87 type: FLOAT .

    $default  reduce using rule 87 (type)


state 3

   88 type: CHAR .

    $default  reduce using rule 88 (type)


state 4

   90 type: BOOL .

    $default  reduce using rule 90 (type)


state 5

   89 type: STRING .

    $default  reduce using rule 89 (type)


state 6

   52 factor: INT_VAL .

    $default  reduce using rule 52 (factor)


state 7

   53 factor: FLOAT_VAL .

    $default  reduce using rule 53 (factor)


state 8

   39 bool_expr: TRUE_VAL .

    $default  reduce using rule 39 (bool_expr)


state 9

   40 bool_expr: FALSE_VAL .

    $default  reduce using rule 40 (bool_expr)


state 10

   43 unary_expr: IDENTIFIER . INC
   44           | IDENTIFIER . DEC
   56 factor: IDENTIFIER .
   57 function_call: IDENTIFIER . LPAREN RPAREN
   58              | IDENTIFIER . LPAREN call_params RPAREN
   70 assign_stmt: IDENTIFIER . ASSIGN value SEMICOLON
   71            | IDENTIFIER . DIV_EQ value SEMICOLON
   72            | IDENTIFIER . MULT_EQ value SEMICOLON
   73            | IDENTIFIER . PLUS_EQ value SEMICOLON
   74            | IDENTIFIER . MINUS_EQ value SEMICOLON

    LPAREN    shift, and go to state 46
    ASSIGN    shift, and go to state 47
    DIV_EQ    shift, and go to state 48
    PLUS_EQ   shift, and go to state 49
    MINUS_EQ  shift, and go to state 50
    MULT_EQ   shift, and go to state 51
    INC       shift, and go to state 52
    DEC       shift, and go to state 53

    $default  reduce using rule 56 (factor)


state 11

   67 const_dec_stmt: CONST . type IDENTIFIER ASSIGN constant SEMICOLON

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type  go to state 54


state 12

    4 stmt: LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 55
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 13

   27 expr: LPAREN . expr RPAREN

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 57
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 14

   15 stmt: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 58


state 15

   16 stmt: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 59


state 16

   75 while_stmt: WHILE . expr LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 60
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 17

   79 for_stmt: FOR . LPAREN var_dec_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE
   80         | FOR . LPAREN assign_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE

    LPAREN  shift, and go to state 61


state 18

   81 switch_stmt: SWITCH . expr LBRACE case_stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 62
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 19

   76 if_stmt: IF . expr LBRACE stmts RBRACE
   77        | IF . expr LBRACE stmts RBRACE ELSE LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 63
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 20

   78 repeat_until_stmt: REPEAT . LBRACE stmts RBRACE UNTIL expr SEMICOLON

    LBRACE  shift, and go to state 64


state 21

   38 bool_expr: NOT . expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 65
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 22

   92 function_prototype: VOID . IDENTIFIER LPAREN params RPAREN
   93                   | VOID . IDENTIFIER LPAREN RPAREN

    IDENTIFIER  shift, and go to state 66


state 23

   14 stmt: RETURN . ret_val SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    $default  reduce using rule 19 (ret_val)

    ret_val          go to state 73
    value            go to state 74
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 24

   17 stmt: PRINT . LPAREN STRING RPAREN SEMICOLON

    LPAREN  shift, and go to state 76


state 25

    0 $accept: stmts . $end
    1 stmts: stmts . stmt

    $end        shift, and go to state 77
    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 26

    2 stmts: stmt .

    $default  reduce using rule 2 (stmts)


state 27

    3 stmt: expr . SEMICOLON
   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr

    SEMICOLON  shift, and go to state 79
    LE         shift, and go to state 80
    GE         shift, and go to state 81
    NE         shift, and go to state 82
    EQUAL      shift, and go to state 83
    LESS       shift, and go to state 84
    GREATER    shift, and go to state 85
    OR         shift, and go to state 86
    AND        shift, and go to state 87


state 28

   28 expr: bool_expr .

    $default  reduce using rule 28 (expr)


state 29

   29 expr: arithmetic_expr .

    $default  reduce using rule 29 (expr)


state 30

   42 arithmetic_expr: unary_expr .

    $default  reduce using rule 42 (arithmetic_expr)


state 31

   41 arithmetic_expr: binary_expr .
   46 binary_expr: binary_expr . PLUS term
   47            | binary_expr . MINUS term

    MINUS  shift, and go to state 88
    PLUS   shift, and go to state 89

    $default  reduce using rule 41 (arithmetic_expr)


state 32

   45 binary_expr: term .
   49 term: term . MULT factor
   50     | term . DIV factor
   51     | term . MOD factor

    MOD   shift, and go to state 90
    DIV   shift, and go to state 91
    MULT  shift, and go to state 92

    $default  reduce using rule 45 (binary_expr)


state 33

   48 term: factor .
   54 factor: factor . EXP factor

    EXP  shift, and go to state 93

    $default  reduce using rule 48 (term)


state 34

   55 factor: function_call .

    $default  reduce using rule 55 (factor)


state 35

    5 stmt: const_dec_stmt .

    $default  reduce using rule 5 (stmt)


state 36

    6 stmt: var_dec_stmt .

    $default  reduce using rule 6 (stmt)


state 37

    7 stmt: assign_stmt .

    $default  reduce using rule 7 (stmt)


state 38

    8 stmt: while_stmt .

    $default  reduce using rule 8 (stmt)


state 39

    9 stmt: if_stmt .

    $default  reduce using rule 9 (stmt)


state 40

   10 stmt: repeat_until_stmt .

    $default  reduce using rule 10 (stmt)


state 41

   11 stmt: for_stmt .

    $default  reduce using rule 11 (stmt)


state 42

   12 stmt: switch_stmt .

    $default  reduce using rule 12 (stmt)


state 43

   68 var_dec_stmt: type . IDENTIFIER SEMICOLON
   69             | type . IDENTIFIER ASSIGN value SEMICOLON
   94 function_prototype: type . IDENTIFIER LPAREN params RPAREN
   95                   | type . IDENTIFIER LPAREN RPAREN

    IDENTIFIER  shift, and go to state 94


state 44

   13 stmt: function .

    $default  reduce using rule 13 (stmt)


state 45

   91 function: function_prototype . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 95


state 46

   57 function_call: IDENTIFIER LPAREN . RPAREN
   58              | IDENTIFIER LPAREN . call_params RPAREN

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    RPAREN      shift, and go to state 96
    NOT         shift, and go to state 21

    value            go to state 97
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34
    call_params      go to state 98


state 47

   70 assign_stmt: IDENTIFIER ASSIGN . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 99
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 48

   71 assign_stmt: IDENTIFIER DIV_EQ . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 100
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 49

   73 assign_stmt: IDENTIFIER PLUS_EQ . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 101
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 50

   74 assign_stmt: IDENTIFIER MINUS_EQ . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 102
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 51

   72 assign_stmt: IDENTIFIER MULT_EQ . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 103
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 52

   43 unary_expr: IDENTIFIER INC .

    $default  reduce using rule 43 (unary_expr)


state 53

   44 unary_expr: IDENTIFIER DEC .

    $default  reduce using rule 44 (unary_expr)


state 54

   67 const_dec_stmt: CONST type . IDENTIFIER ASSIGN constant SEMICOLON

    IDENTIFIER  shift, and go to state 104


state 55

    1 stmts: stmts . stmt
    4 stmt: LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 105
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 56

   43 unary_expr: IDENTIFIER . INC
   44           | IDENTIFIER . DEC
   56 factor: IDENTIFIER .
   57 function_call: IDENTIFIER . LPAREN RPAREN
   58              | IDENTIFIER . LPAREN call_params RPAREN

    LPAREN  shift, and go to state 46
    INC     shift, and go to state 52
    DEC     shift, and go to state 53

    $default  reduce using rule 56 (factor)


state 57

   27 expr: LPAREN expr . RPAREN
   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr

    RPAREN   shift, and go to state 106
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 58

   15 stmt: BREAK SEMICOLON .

    $default  reduce using rule 15 (stmt)


state 59

   16 stmt: CONTINUE SEMICOLON .

    $default  reduce using rule 16 (stmt)


state 60

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   75 while_stmt: WHILE expr . LBRACE stmts RBRACE

    LBRACE   shift, and go to state 107
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 61

   79 for_stmt: FOR LPAREN . var_dec_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE
   80         | FOR LPAREN . assign_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 108

    var_dec_stmt  go to state 109
    assign_stmt   go to state 110
    type          go to state 111


state 62

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   81 switch_stmt: SWITCH expr . LBRACE case_stmts RBRACE

    LBRACE   shift, and go to state 112
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 63

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   76 if_stmt: IF expr . LBRACE stmts RBRACE
   77        | IF expr . LBRACE stmts RBRACE ELSE LBRACE stmts RBRACE

    LBRACE   shift, and go to state 113
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 64

   78 repeat_until_stmt: REPEAT LBRACE . stmts RBRACE UNTIL expr SEMICOLON

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 114
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 65

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   38          | NOT expr .

    OR   error (nonassociative)
    AND  error (nonassociative)

    $default  reduce using rule 38 (bool_expr)


state 66

   92 function_prototype: VOID IDENTIFIER . LPAREN params RPAREN
   93                   | VOID IDENTIFIER . LPAREN RPAREN

    LPAREN  shift, and go to state 115


state 67

   23 value: INT_VAL .
   52 factor: INT_VAL .

    SEMICOLON  reduce using rule 23 (value)
    SEMICOLON  [reduce using rule 52 (factor)]
    COMMA      reduce using rule 23 (value)
    COMMA      [reduce using rule 52 (factor)]
    RPAREN     reduce using rule 23 (value)
    RPAREN     [reduce using rule 52 (factor)]
    COLON      reduce using rule 23 (value)
    COLON      [reduce using rule 52 (factor)]
    $default   reduce using rule 52 (factor)


state 68

   24 value: FLOAT_VAL .
   53 factor: FLOAT_VAL .

    SEMICOLON  reduce using rule 24 (value)
    SEMICOLON  [reduce using rule 53 (factor)]
    COMMA      reduce using rule 24 (value)
    COMMA      [reduce using rule 53 (factor)]
    RPAREN     reduce using rule 24 (value)
    RPAREN     [reduce using rule 53 (factor)]
    COLON      reduce using rule 24 (value)
    COLON      [reduce using rule 53 (factor)]
    $default   reduce using rule 53 (factor)


state 69

   22 value: CHAR_VAL .

    $default  reduce using rule 22 (value)


state 70

   21 value: STRING_VAL .

    $default  reduce using rule 21 (value)


state 71

   25 value: TRUE_VAL .
   39 bool_expr: TRUE_VAL .

    SEMICOLON  reduce using rule 25 (value)
    SEMICOLON  [reduce using rule 39 (bool_expr)]
    COMMA      reduce using rule 25 (value)
    COMMA      [reduce using rule 39 (bool_expr)]
    RPAREN     reduce using rule 25 (value)
    RPAREN     [reduce using rule 39 (bool_expr)]
    COLON      reduce using rule 25 (value)
    COLON      [reduce using rule 39 (bool_expr)]
    $default   reduce using rule 39 (bool_expr)


state 72

   26 value: FALSE_VAL .
   40 bool_expr: FALSE_VAL .

    SEMICOLON  reduce using rule 26 (value)
    SEMICOLON  [reduce using rule 40 (bool_expr)]
    COMMA      reduce using rule 26 (value)
    COMMA      [reduce using rule 40 (bool_expr)]
    RPAREN     reduce using rule 26 (value)
    RPAREN     [reduce using rule 40 (bool_expr)]
    COLON      reduce using rule 26 (value)
    COLON      [reduce using rule 40 (bool_expr)]
    $default   reduce using rule 40 (bool_expr)


state 73

   14 stmt: RETURN ret_val . SEMICOLON

    SEMICOLON  shift, and go to state 116


state 74

   18 ret_val: value .

    $default  reduce using rule 18 (ret_val)


state 75

   20 value: expr .
   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr

    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87

    $default  reduce using rule 20 (value)


state 76

   17 stmt: PRINT LPAREN . STRING RPAREN SEMICOLON

    STRING  shift, and go to state 117


state 77

    0 $accept: stmts $end .

    $default  accept


state 78

    1 stmts: stmts stmt .

    $default  reduce using rule 1 (stmts)


state 79

    3 stmt: expr SEMICOLON .

    $default  reduce using rule 3 (stmt)


state 80

   35 bool_expr: expr LE . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 118
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 81

   34 bool_expr: expr GE . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 119
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 82

   31 bool_expr: expr NE . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 120
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 83

   30 bool_expr: expr EQUAL . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 121
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 84

   33 bool_expr: expr LESS . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 122
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 85

   32 bool_expr: expr GREATER . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 123
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 86

   37 bool_expr: expr OR . arithmetic_expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 56

    arithmetic_expr  go to state 124
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 87

   36 bool_expr: expr AND . expr

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 125
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 88

   47 binary_expr: binary_expr MINUS . term

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    term           go to state 127
    factor         go to state 33
    function_call  go to state 34


state 89

   46 binary_expr: binary_expr PLUS . term

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    term           go to state 128
    factor         go to state 33
    function_call  go to state 34


state 90

   51 term: term MOD . factor

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    factor         go to state 129
    function_call  go to state 34


state 91

   50 term: term DIV . factor

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    factor         go to state 130
    function_call  go to state 34


state 92

   49 term: term MULT . factor

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    factor         go to state 131
    function_call  go to state 34


state 93

   54 factor: factor EXP . factor

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    IDENTIFIER  shift, and go to state 126

    factor         go to state 132
    function_call  go to state 34


state 94

   68 var_dec_stmt: type IDENTIFIER . SEMICOLON
   69             | type IDENTIFIER . ASSIGN value SEMICOLON
   94 function_prototype: type IDENTIFIER . LPAREN params RPAREN
   95                   | type IDENTIFIER . LPAREN RPAREN

    SEMICOLON  shift, and go to state 133
    LPAREN     shift, and go to state 134
    ASSIGN     shift, and go to state 135


state 95

   91 function: function_prototype LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 136
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 96

   57 function_call: IDENTIFIER LPAREN RPAREN .

    $default  reduce using rule 57 (function_call)


state 97

   60 call_params: value .

    $default  reduce using rule 60 (call_params)


state 98

   58 function_call: IDENTIFIER LPAREN call_params . RPAREN
   59 call_params: call_params . COMMA value

    COMMA   shift, and go to state 137
    RPAREN  shift, and go to state 138


state 99

   70 assign_stmt: IDENTIFIER ASSIGN value . SEMICOLON

    SEMICOLON  shift, and go to state 139


state 100

   71 assign_stmt: IDENTIFIER DIV_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 140


state 101

   73 assign_stmt: IDENTIFIER PLUS_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 141


state 102

   74 assign_stmt: IDENTIFIER MINUS_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 142


state 103

   72 assign_stmt: IDENTIFIER MULT_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 143


state 104

   67 const_dec_stmt: CONST type IDENTIFIER . ASSIGN constant SEMICOLON

    ASSIGN  shift, and go to state 144


state 105

    4 stmt: LBRACE stmts RBRACE .

    $default  reduce using rule 4 (stmt)


state 106

   27 expr: LPAREN expr RPAREN .

    $default  reduce using rule 27 (expr)


state 107

   75 while_stmt: WHILE expr LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 145
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 108

   70 assign_stmt: IDENTIFIER . ASSIGN value SEMICOLON
   71            | IDENTIFIER . DIV_EQ value SEMICOLON
   72            | IDENTIFIER . MULT_EQ value SEMICOLON
   73            | IDENTIFIER . PLUS_EQ value SEMICOLON
   74            | IDENTIFIER . MINUS_EQ value SEMICOLON

    ASSIGN    shift, and go to state 47
    DIV_EQ    shift, and go to state 48
    PLUS_EQ   shift, and go to state 49
    MINUS_EQ  shift, and go to state 50
    MULT_EQ   shift, and go to state 51


state 109

   79 for_stmt: FOR LPAREN var_dec_stmt . expr SEMICOLON expr RPAREN LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 146
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 110

   80 for_stmt: FOR LPAREN assign_stmt . expr SEMICOLON expr RPAREN LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 147
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 111

   68 var_dec_stmt: type . IDENTIFIER SEMICOLON
   69             | type . IDENTIFIER ASSIGN value SEMICOLON

    IDENTIFIER  shift, and go to state 148


state 112

   81 switch_stmt: SWITCH expr LBRACE . case_stmts RBRACE

    CASE     shift, and go to state 149
    DEFAULT  shift, and go to state 150

    case_stmts  go to state 151
    case_stmt   go to state 152


state 113

   76 if_stmt: IF expr LBRACE . stmts RBRACE
   77        | IF expr LBRACE . stmts RBRACE ELSE LBRACE stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 153
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 114

    1 stmts: stmts . stmt
   78 repeat_until_stmt: REPEAT LBRACE stmts . RBRACE UNTIL expr SEMICOLON

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 154
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 115

   92 function_prototype: VOID IDENTIFIER LPAREN . params RPAREN
   93                   | VOID IDENTIFIER LPAREN . RPAREN

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5
    RPAREN  shift, and go to state 155

    type    go to state 156
    params  go to state 157
    param   go to state 158


state 116

   14 stmt: RETURN ret_val SEMICOLON .

    $default  reduce using rule 14 (stmt)


state 117

   17 stmt: PRINT LPAREN STRING . RPAREN SEMICOLON

    RPAREN  shift, and go to state 159


state 118

   35 bool_expr: expr LE arithmetic_expr .

    $default  reduce using rule 35 (bool_expr)


state 119

   34 bool_expr: expr GE arithmetic_expr .

    $default  reduce using rule 34 (bool_expr)


state 120

   31 bool_expr: expr NE arithmetic_expr .

    $default  reduce using rule 31 (bool_expr)


state 121

   30 bool_expr: expr EQUAL arithmetic_expr .

    $default  reduce using rule 30 (bool_expr)


state 122

   33 bool_expr: expr LESS arithmetic_expr .

    $default  reduce using rule 33 (bool_expr)


state 123

   32 bool_expr: expr GREATER arithmetic_expr .

    $default  reduce using rule 32 (bool_expr)


state 124

   37 bool_expr: expr OR arithmetic_expr .

    $default  reduce using rule 37 (bool_expr)


state 125

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   36          | expr AND expr .
   37          | expr . OR arithmetic_expr

    OR   error (nonassociative)
    AND  error (nonassociative)

    $default  reduce using rule 36 (bool_expr)


state 126

   56 factor: IDENTIFIER .
   57 function_call: IDENTIFIER . LPAREN RPAREN
   58              | IDENTIFIER . LPAREN call_params RPAREN

    LPAREN  shift, and go to state 46

    $default  reduce using rule 56 (factor)


state 127

   47 binary_expr: binary_expr MINUS term .
   49 term: term . MULT factor
   50     | term . DIV factor
   51     | term . MOD factor

    MOD   shift, and go to state 90
    DIV   shift, and go to state 91
    MULT  shift, and go to state 92

    $default  reduce using rule 47 (binary_expr)


state 128

   46 binary_expr: binary_expr PLUS term .
   49 term: term . MULT factor
   50     | term . DIV factor
   51     | term . MOD factor

    MOD   shift, and go to state 90
    DIV   shift, and go to state 91
    MULT  shift, and go to state 92

    $default  reduce using rule 46 (binary_expr)


state 129

   51 term: term MOD factor .
   54 factor: factor . EXP factor

    EXP  shift, and go to state 93

    $default  reduce using rule 51 (term)


state 130

   50 term: term DIV factor .
   54 factor: factor . EXP factor

    EXP  shift, and go to state 93

    $default  reduce using rule 50 (term)


state 131

   49 term: term MULT factor .
   54 factor: factor . EXP factor

    EXP  shift, and go to state 93

    $default  reduce using rule 49 (term)


state 132

   54 factor: factor . EXP factor
   54       | factor EXP factor .

    $default  reduce using rule 54 (factor)


state 133

   68 var_dec_stmt: type IDENTIFIER SEMICOLON .

    $default  reduce using rule 68 (var_dec_stmt)


state 134

   94 function_prototype: type IDENTIFIER LPAREN . params RPAREN
   95                   | type IDENTIFIER LPAREN . RPAREN

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5
    RPAREN  shift, and go to state 160

    type    go to state 156
    params  go to state 161
    param   go to state 158


state 135

   69 var_dec_stmt: type IDENTIFIER ASSIGN . value SEMICOLON

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 162
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 136

    1 stmts: stmts . stmt
   91 function: function_prototype LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 163
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 137

   59 call_params: call_params COMMA . value

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 164
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 138

   58 function_call: IDENTIFIER LPAREN call_params RPAREN .

    $default  reduce using rule 58 (function_call)


state 139

   70 assign_stmt: IDENTIFIER ASSIGN value SEMICOLON .

    $default  reduce using rule 70 (assign_stmt)


state 140

   71 assign_stmt: IDENTIFIER DIV_EQ value SEMICOLON .

    $default  reduce using rule 71 (assign_stmt)


state 141

   73 assign_stmt: IDENTIFIER PLUS_EQ value SEMICOLON .

    $default  reduce using rule 73 (assign_stmt)


state 142

   74 assign_stmt: IDENTIFIER MINUS_EQ value SEMICOLON .

    $default  reduce using rule 74 (assign_stmt)


state 143

   72 assign_stmt: IDENTIFIER MULT_EQ value SEMICOLON .

    $default  reduce using rule 72 (assign_stmt)


state 144

   67 const_dec_stmt: CONST type IDENTIFIER ASSIGN . constant SEMICOLON

    INT_VAL     shift, and go to state 165
    FLOAT_VAL   shift, and go to state 166
    CHAR_VAL    shift, and go to state 167
    STRING_VAL  shift, and go to state 168
    TRUE_VAL    shift, and go to state 169
    FALSE_VAL   shift, and go to state 170

    constant  go to state 171


state 145

    1 stmts: stmts . stmt
   75 while_stmt: WHILE expr LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 172
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 146

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   79 for_stmt: FOR LPAREN var_dec_stmt expr . SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  shift, and go to state 173
    LE         shift, and go to state 80
    GE         shift, and go to state 81
    NE         shift, and go to state 82
    EQUAL      shift, and go to state 83
    LESS       shift, and go to state 84
    GREATER    shift, and go to state 85
    OR         shift, and go to state 86
    AND        shift, and go to state 87


state 147

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   80 for_stmt: FOR LPAREN assign_stmt expr . SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  shift, and go to state 174
    LE         shift, and go to state 80
    GE         shift, and go to state 81
    NE         shift, and go to state 82
    EQUAL      shift, and go to state 83
    LESS       shift, and go to state 84
    GREATER    shift, and go to state 85
    OR         shift, and go to state 86
    AND        shift, and go to state 87


state 148

   68 var_dec_stmt: type IDENTIFIER . SEMICOLON
   69             | type IDENTIFIER . ASSIGN value SEMICOLON

    SEMICOLON  shift, and go to state 133
    ASSIGN     shift, and go to state 135


state 149

   84 case_stmt: CASE . value COLON stmts

    INT_VAL     shift, and go to state 67
    FLOAT_VAL   shift, and go to state 68
    CHAR_VAL    shift, and go to state 69
    STRING_VAL  shift, and go to state 70
    TRUE_VAL    shift, and go to state 71
    FALSE_VAL   shift, and go to state 72
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    value            go to state 175
    expr             go to state 75
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 150

   85 case_stmt: DEFAULT . COLON stmts

    COLON  shift, and go to state 176


state 151

   81 switch_stmt: SWITCH expr LBRACE case_stmts . RBRACE
   82 case_stmts: case_stmts . case_stmt

    RBRACE   shift, and go to state 177
    CASE     shift, and go to state 149
    DEFAULT  shift, and go to state 150

    case_stmt  go to state 178


state 152

   83 case_stmts: case_stmt .

    $default  reduce using rule 83 (case_stmts)


state 153

    1 stmts: stmts . stmt
   76 if_stmt: IF expr LBRACE stmts . RBRACE
   77        | IF expr LBRACE stmts . RBRACE ELSE LBRACE stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 179
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 154

   78 repeat_until_stmt: REPEAT LBRACE stmts RBRACE . UNTIL expr SEMICOLON

    UNTIL  shift, and go to state 180


state 155

   93 function_prototype: VOID IDENTIFIER LPAREN RPAREN .

    $default  reduce using rule 93 (function_prototype)


state 156

   99 param: type . IDENTIFIER $@1 type IDENTIFIER ASSIGN constant

    IDENTIFIER  shift, and go to state 181


state 157

   92 function_prototype: VOID IDENTIFIER LPAREN params . RPAREN
   97 params: params . COMMA param

    COMMA   shift, and go to state 182
    RPAREN  shift, and go to state 183


state 158

   96 params: param .

    $default  reduce using rule 96 (params)


state 159

   17 stmt: PRINT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON  shift, and go to state 184


state 160

   95 function_prototype: type IDENTIFIER LPAREN RPAREN .

    $default  reduce using rule 95 (function_prototype)


state 161

   94 function_prototype: type IDENTIFIER LPAREN params . RPAREN
   97 params: params . COMMA param

    COMMA   shift, and go to state 182
    RPAREN  shift, and go to state 185


state 162

   69 var_dec_stmt: type IDENTIFIER ASSIGN value . SEMICOLON

    SEMICOLON  shift, and go to state 186


state 163

   91 function: function_prototype LBRACE stmts RBRACE .

    $default  reduce using rule 91 (function)


state 164

   59 call_params: call_params COMMA value .

    $default  reduce using rule 59 (call_params)


state 165

   61 constant: INT_VAL .

    $default  reduce using rule 61 (constant)


state 166

   62 constant: FLOAT_VAL .

    $default  reduce using rule 62 (constant)


state 167

   64 constant: CHAR_VAL .

    $default  reduce using rule 64 (constant)


state 168

   63 constant: STRING_VAL .

    $default  reduce using rule 63 (constant)


state 169

   65 constant: TRUE_VAL .

    $default  reduce using rule 65 (constant)


state 170

   66 constant: FALSE_VAL .

    $default  reduce using rule 66 (constant)


state 171

   67 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant . SEMICOLON

    SEMICOLON  shift, and go to state 187


state 172

   75 while_stmt: WHILE expr LBRACE stmts RBRACE .

    $default  reduce using rule 75 (while_stmt)


state 173

   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON . expr RPAREN LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 188
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 174

   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON . expr RPAREN LBRACE stmts RBRACE

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 189
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 175

   84 case_stmt: CASE value . COLON stmts

    COLON  shift, and go to state 190


state 176

   85 case_stmt: DEFAULT COLON . stmts

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 191
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 177

   81 switch_stmt: SWITCH expr LBRACE case_stmts RBRACE .

    $default  reduce using rule 81 (switch_stmt)


state 178

   82 case_stmts: case_stmts case_stmt .

    $default  reduce using rule 82 (case_stmts)


state 179

   76 if_stmt: IF expr LBRACE stmts RBRACE .
   77        | IF expr LBRACE stmts RBRACE . ELSE LBRACE stmts RBRACE

    ELSE  shift, and go to state 192

    $default  reduce using rule 76 (if_stmt)


state 180

   78 repeat_until_stmt: REPEAT LBRACE stmts RBRACE UNTIL . expr SEMICOLON

    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 56
    LPAREN      shift, and go to state 13
    NOT         shift, and go to state 21

    expr             go to state 193
    bool_expr        go to state 28
    arithmetic_expr  go to state 29
    unary_expr       go to state 30
    binary_expr      go to state 31
    term             go to state 32
    factor           go to state 33
    function_call    go to state 34


state 181

   99 param: type IDENTIFIER . $@1 type IDENTIFIER ASSIGN constant

    $default  reduce using rule 98 ($@1)

    $@1  go to state 194


state 182

   97 params: params COMMA . param

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type   go to state 156
    param  go to state 195


state 183

   92 function_prototype: VOID IDENTIFIER LPAREN params RPAREN .

    $default  reduce using rule 92 (function_prototype)


state 184

   17 stmt: PRINT LPAREN STRING RPAREN SEMICOLON .

    $default  reduce using rule 17 (stmt)


state 185

   94 function_prototype: type IDENTIFIER LPAREN params RPAREN .

    $default  reduce using rule 94 (function_prototype)


state 186

   69 var_dec_stmt: type IDENTIFIER ASSIGN value SEMICOLON .

    $default  reduce using rule 69 (var_dec_stmt)


state 187

   67 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant SEMICOLON .

    $default  reduce using rule 67 (const_dec_stmt)


state 188

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr . RPAREN LBRACE stmts RBRACE

    RPAREN   shift, and go to state 196
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 189

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON expr . RPAREN LBRACE stmts RBRACE

    RPAREN   shift, and go to state 197
    LE       shift, and go to state 80
    GE       shift, and go to state 81
    NE       shift, and go to state 82
    EQUAL    shift, and go to state 83
    LESS     shift, and go to state 84
    GREATER  shift, and go to state 85
    OR       shift, and go to state 86
    AND      shift, and go to state 87


state 190

   84 case_stmt: CASE value COLON . stmts

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 198
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 191

    1 stmts: stmts . stmt
   85 case_stmt: DEFAULT COLON stmts .

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    $default  reduce using rule 85 (case_stmt)

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 192

   77 if_stmt: IF expr LBRACE stmts RBRACE ELSE . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 199


state 193

   30 bool_expr: expr . EQUAL arithmetic_expr
   31          | expr . NE arithmetic_expr
   32          | expr . GREATER arithmetic_expr
   33          | expr . LESS arithmetic_expr
   34          | expr . GE arithmetic_expr
   35          | expr . LE arithmetic_expr
   36          | expr . AND expr
   37          | expr . OR arithmetic_expr
   78 repeat_until_stmt: REPEAT LBRACE stmts RBRACE UNTIL expr . SEMICOLON

    SEMICOLON  shift, and go to state 200
    LE         shift, and go to state 80
    GE         shift, and go to state 81
    NE         shift, and go to state 82
    EQUAL      shift, and go to state 83
    LESS       shift, and go to state 84
    GREATER    shift, and go to state 85
    OR         shift, and go to state 86
    AND        shift, and go to state 87


state 194

   99 param: type IDENTIFIER $@1 . type IDENTIFIER ASSIGN constant

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type  go to state 201


state 195

   97 params: params COMMA param .

    $default  reduce using rule 97 (params)


state 196

   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr RPAREN . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 202


state 197

   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON expr RPAREN . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 203


state 198

    1 stmts: stmts . stmt
   84 case_stmt: CASE value COLON stmts .

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    $default  reduce using rule 84 (case_stmt)

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 199

   77 if_stmt: IF expr LBRACE stmts RBRACE ELSE LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 204
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 200

   78 repeat_until_stmt: REPEAT LBRACE stmts RBRACE UNTIL expr SEMICOLON .

    $default  reduce using rule 78 (repeat_until_stmt)


state 201

   99 param: type IDENTIFIER $@1 type . IDENTIFIER ASSIGN constant

    IDENTIFIER  shift, and go to state 205


state 202

   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr RPAREN LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 206
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 203

   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON expr RPAREN LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmts               go to state 207
    stmt                go to state 26
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 204

    1 stmts: stmts . stmt
   77 if_stmt: IF expr LBRACE stmts RBRACE ELSE LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 208
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 205

   99 param: type IDENTIFIER $@1 type IDENTIFIER . ASSIGN constant

    ASSIGN  shift, and go to state 209


state 206

    1 stmts: stmts . stmt
   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr RPAREN LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 210
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 207

    1 stmts: stmts . stmt
   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON expr RPAREN LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    INT_VAL     shift, and go to state 6
    FLOAT_VAL   shift, and go to state 7
    TRUE_VAL    shift, and go to state 8
    FALSE_VAL   shift, and go to state 9
    IDENTIFIER  shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 211
    LPAREN      shift, and go to state 13
    BREAK       shift, and go to state 14
    CONTINUE    shift, and go to state 15
    WHILE       shift, and go to state 16
    FOR         shift, and go to state 17
    SWITCH      shift, and go to state 18
    IF          shift, and go to state 19
    REPEAT      shift, and go to state 20
    NOT         shift, and go to state 21
    VOID        shift, and go to state 22
    RETURN      shift, and go to state 23
    PRINT       shift, and go to state 24

    stmt                go to state 78
    expr                go to state 27
    bool_expr           go to state 28
    arithmetic_expr     go to state 29
    unary_expr          go to state 30
    binary_expr         go to state 31
    term                go to state 32
    factor              go to state 33
    function_call       go to state 34
    const_dec_stmt      go to state 35
    var_dec_stmt        go to state 36
    assign_stmt         go to state 37
    while_stmt          go to state 38
    if_stmt             go to state 39
    repeat_until_stmt   go to state 40
    for_stmt            go to state 41
    switch_stmt         go to state 42
    type                go to state 43
    function            go to state 44
    function_prototype  go to state 45


state 208

   77 if_stmt: IF expr LBRACE stmts RBRACE ELSE LBRACE stmts RBRACE .

    $default  reduce using rule 77 (if_stmt)


state 209

   99 param: type IDENTIFIER $@1 type IDENTIFIER ASSIGN . constant

    INT_VAL     shift, and go to state 165
    FLOAT_VAL   shift, and go to state 166
    CHAR_VAL    shift, and go to state 167
    STRING_VAL  shift, and go to state 168
    TRUE_VAL    shift, and go to state 169
    FALSE_VAL   shift, and go to state 170

    constant  go to state 212


state 210

   79 for_stmt: FOR LPAREN var_dec_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE .

    $default  reduce using rule 79 (for_stmt)


state 211

   80 for_stmt: FOR LPAREN assign_stmt expr SEMICOLON expr RPAREN LBRACE stmts RBRACE .

    $default  reduce using rule 80 (for_stmt)


state 212

   99 param: type IDENTIFIER $@1 type IDENTIFIER ASSIGN constant .

    $default  reduce using rule 99 (param)
