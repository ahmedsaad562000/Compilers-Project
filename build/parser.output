Terminals unused in grammar

   CONTINUE
   PRINT


Grammar

    0 $accept: stmts $end

    1 stmts: stmts stmt
    2      | stmt

    3 stmt: expr SEMICOLON

    4 $@1: /* empty */

    5 stmt: LBRACE $@1 stmts RBRACE
    6     | const_dec_stmt
    7     | var_dec_stmt
    8     | assign_stmt
    9     | while_stmt
   10     | if_stmt
   11     | repeat_until_stmt
   12     | for_stmt
   13     | switch_stmt
   14     | function

   15 ret_val: value
   16        | /* empty */

   17 value: expr
   18      | STRING_VAL
   19      | CHAR_VAL

   20 expr: bool_expr
   21     | arithmetic_expr

   22 bool_expr: expr EQUAL arithmetic_expr
   23          | expr NE arithmetic_expr
   24          | expr GREATER arithmetic_expr
   25          | expr LESS arithmetic_expr
   26          | expr GE arithmetic_expr
   27          | expr LE arithmetic_expr
   28          | expr AND expr
   29          | expr OR expr
   30          | NOT expr
   31          | LPAREN bool_expr RPAREN
   32          | TRUE_VAL
   33          | FALSE_VAL

   34 arithmetic_expr: binary_expr
   35                | unary_expr

   36 unary_expr: IDENTIFIER INC
   37           | IDENTIFIER DEC

   38 binary_expr: term
   39            | binary_expr PLUS term
   40            | binary_expr MINUS term

   41 term: negat
   42     | term MULT factor
   43     | term DIV factor
   44     | term MOD factor

   45 negat: para
   46      | MINUS para

   47 para: factor
   48     | LPAREN binary_expr RPAREN
   49     | para EXP para

   50 factor: INT_VAL
   51       | FLOAT_VAL
   52       | function_call
   53       | IDENTIFIER

   54 $@2: /* empty */

   55 function_call: IDENTIFIER LPAREN $@2 RPAREN

   56 $@3: /* empty */

   57 function_call: IDENTIFIER LPAREN $@3 call_params RPAREN

   58 call_params: call_params COMMA value
   59            | value

   60 constant: INT_VAL
   61         | FLOAT_VAL
   62         | STRING_VAL
   63         | CHAR_VAL
   64         | TRUE_VAL
   65         | FALSE_VAL

   66 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant SEMICOLON

   67 var_dec_stmt: type IDENTIFIER SEMICOLON
   68             | type IDENTIFIER ASSIGN value SEMICOLON

   69 assign_stmt: IDENTIFIER ASSIGN value SEMICOLON
   70            | IDENTIFIER DIV_EQ value SEMICOLON
   71            | IDENTIFIER MULT_EQ value SEMICOLON
   72            | IDENTIFIER PLUS_EQ value SEMICOLON
   73            | IDENTIFIER MINUS_EQ value SEMICOLON

   74 $@4: /* empty */

   75 $@5: /* empty */

   76 $@6: /* empty */

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN LBRACE $@6 stmts RBRACE

   78 $@7: /* empty */

   79 $@8: /* empty */

   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE $@8 stmts RBRACE if_body

   81 $@9: /* empty */

   82 $@10: /* empty */

   83 $@11: /* empty */

   84 if_body: $@9 ELSE $@10 LBRACE $@11 stmts RBRACE
   85        | /* empty */

   86 $@12: /* empty */

   87 $@13: /* empty */

   88 $@14: /* empty */

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

   90 $@15: /* empty */

   91 for_stmt: FOR $@15 for_expression_stmt

   92 $@16: /* empty */

   93 $@17: /* empty */

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE

   95 $@18: /* empty */

   96 $@19: /* empty */

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE

   98 $@20: /* empty */

   99 $@21: /* empty */

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN LBRACE $@21 case_stmts RBRACE

  101 case_stmts: case_stmts case_stmt
  102           | case_stmt

  103 $@22: /* empty */

  104 case_stmt: CASE constant COLON $@22 case_in_scope_stmts case_end

  105 $@23: /* empty */

  106 case_stmt: DEFAULT COLON $@23 case_in_scope_stmts default_case_end

  107 case_in_scope_stmts: stmts
  108                    | /* empty */

  109 case_end: BREAK SEMICOLON
  110         | /* empty */

  111 default_case_end: BREAK SEMICOLON
  112                 | /* empty */

  113 type: INT
  114     | FLOAT
  115     | CHAR
  116     | STRING
  117     | BOOL

  118 function: function_prototype LBRACE stmts ret_stmt RBRACE

  119 ret_stmt: RETURN ret_val SEMICOLON
  120         | /* empty */

  121 $@24: /* empty */

  122 function_prototype: VOID IDENTIFIER LPAREN $@24 params RPAREN

  123 $@25: /* empty */

  124 function_prototype: VOID IDENTIFIER LPAREN $@25 RPAREN

  125 $@26: /* empty */

  126 function_prototype: type IDENTIFIER LPAREN $@26 params RPAREN

  127 $@27: /* empty */

  128 function_prototype: type IDENTIFIER LPAREN $@27 RPAREN

  129 params: param
  130       | params COMMA param

  131 param: type IDENTIFIER
  132      | type IDENTIFIER ASSIGN constant


Terminals, with rules where they appear

$end (0) 0
error (256)
INT (258) 113
FLOAT (259) 114
CHAR (260) 115
BOOL (261) 117
STRING (262) 116
IDENTIFIER (263) 36 37 53 55 57 66 67 68 69 70 71 72 73 122 124 126
    128 131 132
INT_VAL (264) 50 60
FLOAT_VAL (265) 51 61
CHAR_VAL (266) 19 63
STRING_VAL (267) 18 62
TRUE_VAL (268) 32 64
FALSE_VAL (269) 33 65
CONST (270) 66
SEMICOLON (271) 3 66 67 68 69 70 71 72 73 89 94 97 109 111 119
COMMA (272) 58 130
LBRACE (273) 5 77 80 84 89 94 97 100 118
RBRACE (274) 5 77 80 84 89 94 97 100 118
LPAREN (275) 31 48 55 57 77 80 89 94 97 100 122 124 126 128
RPAREN (276) 31 48 55 57 77 80 89 94 97 100 122 124 126 128
BREAK (277) 109 111
CONTINUE (278)
WHILE (279) 77
FOR (280) 91
SWITCH (281) 100
CASE (282) 104
DEFAULT (283) 106
COLON (284) 104 106
IF (285) 80
ELSE (286) 84
REPEAT (287) 89
UNTIL (288) 89
LE (289) 27
GE (290) 26
NE (291) 23
EQUAL (292) 22
LESS (293) 25
GREATER (294) 24
MINUS (295) 40 46
PLUS (296) 39
MOD (297) 44
DIV (298) 43
MULT (299) 42
EXP (300) 49
OR (301) 29
AND (302) 28
NOT (303) 30
ASSIGN (304) 66 68 69 132
DIV_EQ (305) 70
PLUS_EQ (306) 72
MINUS_EQ (307) 73
MULT_EQ (308) 71
INC (309) 36
DEC (310) 37
UMINUS (311)
VOID (312) 122 124
RETURN (313) 119
PRINT (314)


Nonterminals, with rules where they appear

$accept (60)
    on left: 0
stmts (61)
    on left: 1 2, on right: 0 1 5 77 80 84 89 94 97 107 118
stmt (62)
    on left: 3 5 6 7 8 9 10 11 12 13 14, on right: 1 2
$@1 (63)
    on left: 4, on right: 5
ret_val (64)
    on left: 15 16, on right: 119
value (65)
    on left: 17 18 19, on right: 15 58 59 68 69 70 71 72 73
expr (66)
    on left: 20 21, on right: 3 17 22 23 24 25 26 27 28 29 30 80 94
    97 100
bool_expr (67)
    on left: 22 23 24 25 26 27 28 29 30 31 32 33, on right: 20 31 77
    89 94 97
arithmetic_expr (68)
    on left: 34 35, on right: 21 22 23 24 25 26 27
unary_expr (69)
    on left: 36 37, on right: 35
binary_expr (70)
    on left: 38 39 40, on right: 34 39 40 48
term (71)
    on left: 41 42 43 44, on right: 38 39 40 42 43 44
negat (72)
    on left: 45 46, on right: 41
para (73)
    on left: 47 48 49, on right: 45 46 49
factor (74)
    on left: 50 51 52 53, on right: 42 43 44 47
function_call (75)
    on left: 55 57, on right: 52
$@2 (76)
    on left: 54, on right: 55
$@3 (77)
    on left: 56, on right: 57
call_params (78)
    on left: 58 59, on right: 57 58
constant (79)
    on left: 60 61 62 63 64 65, on right: 66 104 132
const_dec_stmt (80)
    on left: 66, on right: 6
var_dec_stmt (81)
    on left: 67 68, on right: 7 94
assign_stmt (82)
    on left: 69 70 71 72 73, on right: 8 97
while_stmt (83)
    on left: 77, on right: 9
$@4 (84)
    on left: 74, on right: 77
$@5 (85)
    on left: 75, on right: 77
$@6 (86)
    on left: 76, on right: 77
if_stmt (87)
    on left: 80, on right: 10
$@7 (88)
    on left: 78, on right: 80
$@8 (89)
    on left: 79, on right: 80
if_body (90)
    on left: 84 85, on right: 80
$@9 (91)
    on left: 81, on right: 84
$@10 (92)
    on left: 82, on right: 84
$@11 (93)
    on left: 83, on right: 84
repeat_until_stmt (94)
    on left: 89, on right: 11
$@12 (95)
    on left: 86, on right: 89
$@13 (96)
    on left: 87, on right: 89
$@14 (97)
    on left: 88, on right: 89
for_stmt (98)
    on left: 91, on right: 12
$@15 (99)
    on left: 90, on right: 91
for_expression_stmt (100)
    on left: 94 97, on right: 91
$@16 (101)
    on left: 92, on right: 94
$@17 (102)
    on left: 93, on right: 94
$@18 (103)
    on left: 95, on right: 97
$@19 (104)
    on left: 96, on right: 97
switch_stmt (105)
    on left: 100, on right: 13
$@20 (106)
    on left: 98, on right: 100
$@21 (107)
    on left: 99, on right: 100
case_stmts (108)
    on left: 101 102, on right: 100 101
case_stmt (109)
    on left: 104 106, on right: 101 102
$@22 (110)
    on left: 103, on right: 104
$@23 (111)
    on left: 105, on right: 106
case_in_scope_stmts (112)
    on left: 107 108, on right: 104 106
case_end (113)
    on left: 109 110, on right: 104
default_case_end (114)
    on left: 111 112, on right: 106
type (115)
    on left: 113 114 115 116 117, on right: 66 67 68 126 128 131 132
function (116)
    on left: 118, on right: 14
ret_stmt (117)
    on left: 119 120, on right: 118
function_prototype (118)
    on left: 122 124 126 128, on right: 118
$@24 (119)
    on left: 121, on right: 122
$@25 (120)
    on left: 123, on right: 124
$@26 (121)
    on left: 125, on right: 126
$@27 (122)
    on left: 127, on right: 128
params (123)
    on left: 129 130, on right: 122 126 130
param (124)
    on left: 131 132, on right: 129 130


state 0

    0 $accept: . stmts $end

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 22
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 1

  113 type: INT .

    $default  reduce using rule 113 (type)


state 2

  114 type: FLOAT .

    $default  reduce using rule 114 (type)


state 3

  115 type: CHAR .

    $default  reduce using rule 115 (type)


state 4

  117 type: BOOL .

    $default  reduce using rule 117 (type)


state 5

  116 type: STRING .

    $default  reduce using rule 116 (type)


state 6

   36 unary_expr: IDENTIFIER . INC
   37           | IDENTIFIER . DEC
   53 factor: IDENTIFIER .
   55 function_call: IDENTIFIER . LPAREN $@2 RPAREN
   57              | IDENTIFIER . LPAREN $@3 call_params RPAREN
   69 assign_stmt: IDENTIFIER . ASSIGN value SEMICOLON
   70            | IDENTIFIER . DIV_EQ value SEMICOLON
   71            | IDENTIFIER . MULT_EQ value SEMICOLON
   72            | IDENTIFIER . PLUS_EQ value SEMICOLON
   73            | IDENTIFIER . MINUS_EQ value SEMICOLON

    LPAREN    shift, and go to state 45
    ASSIGN    shift, and go to state 46
    DIV_EQ    shift, and go to state 47
    PLUS_EQ   shift, and go to state 48
    MINUS_EQ  shift, and go to state 49
    MULT_EQ   shift, and go to state 50
    INC       shift, and go to state 51
    DEC       shift, and go to state 52

    $default  reduce using rule 53 (factor)


state 7

   50 factor: INT_VAL .

    $default  reduce using rule 50 (factor)


state 8

   51 factor: FLOAT_VAL .

    $default  reduce using rule 51 (factor)


state 9

   32 bool_expr: TRUE_VAL .

    $default  reduce using rule 32 (bool_expr)


state 10

   33 bool_expr: FALSE_VAL .

    $default  reduce using rule 33 (bool_expr)


state 11

   66 const_dec_stmt: CONST . type IDENTIFIER ASSIGN constant SEMICOLON

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type  go to state 53


state 12

    5 stmt: LBRACE . $@1 stmts RBRACE

    $default  reduce using rule 4 ($@1)

    $@1  go to state 54


state 13

   31 bool_expr: LPAREN . bool_expr RPAREN
   48 para: LPAREN . binary_expr RPAREN

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 56
    bool_expr        go to state 57
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 58
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 14

   77 while_stmt: WHILE . LPAREN $@4 bool_expr $@5 RPAREN LBRACE $@6 stmts RBRACE

    LPAREN  shift, and go to state 59


state 15

   91 for_stmt: FOR . $@15 for_expression_stmt

    $default  reduce using rule 90 ($@15)

    $@15  go to state 60


state 16

  100 switch_stmt: SWITCH . LPAREN expr $@20 RPAREN LBRACE $@21 case_stmts RBRACE

    LPAREN  shift, and go to state 61


state 17

   80 if_stmt: IF . LPAREN expr $@7 RPAREN LBRACE $@8 stmts RBRACE if_body

    LPAREN  shift, and go to state 62


state 18

   89 repeat_until_stmt: REPEAT . LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    LBRACE  shift, and go to state 63


state 19

   46 negat: MINUS . para

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65

    para           go to state 66
    factor         go to state 32
    function_call  go to state 33


state 20

   30 bool_expr: NOT . expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 67
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 21

  122 function_prototype: VOID . IDENTIFIER LPAREN $@24 params RPAREN
  124                   | VOID . IDENTIFIER LPAREN $@25 RPAREN

    IDENTIFIER  shift, and go to state 68


state 22

    0 $accept: stmts . $end
    1 stmts: stmts . stmt

    $end        shift, and go to state 69
    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 23

    2 stmts: stmt .

    $default  reduce using rule 2 (stmts)


state 24

    3 stmt: expr . SEMICOLON
   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr

    SEMICOLON  shift, and go to state 71
    LE         shift, and go to state 72
    GE         shift, and go to state 73
    NE         shift, and go to state 74
    EQUAL      shift, and go to state 75
    LESS       shift, and go to state 76
    GREATER    shift, and go to state 77
    OR         shift, and go to state 78
    AND        shift, and go to state 79


state 25

   20 expr: bool_expr .

    $default  reduce using rule 20 (expr)


state 26

   21 expr: arithmetic_expr .

    $default  reduce using rule 21 (expr)


state 27

   35 arithmetic_expr: unary_expr .

    $default  reduce using rule 35 (arithmetic_expr)


state 28

   34 arithmetic_expr: binary_expr .
   39 binary_expr: binary_expr . PLUS term
   40            | binary_expr . MINUS term

    MINUS  shift, and go to state 80
    PLUS   shift, and go to state 81

    $default  reduce using rule 34 (arithmetic_expr)


state 29

   38 binary_expr: term .
   42 term: term . MULT factor
   43     | term . DIV factor
   44     | term . MOD factor

    MOD   shift, and go to state 82
    DIV   shift, and go to state 83
    MULT  shift, and go to state 84

    $default  reduce using rule 38 (binary_expr)


state 30

   41 term: negat .

    $default  reduce using rule 41 (term)


state 31

   45 negat: para .
   49 para: para . EXP para

    EXP  shift, and go to state 85

    $default  reduce using rule 45 (negat)


state 32

   47 para: factor .

    $default  reduce using rule 47 (para)


state 33

   52 factor: function_call .

    $default  reduce using rule 52 (factor)


state 34

    6 stmt: const_dec_stmt .

    $default  reduce using rule 6 (stmt)


state 35

    7 stmt: var_dec_stmt .

    $default  reduce using rule 7 (stmt)


state 36

    8 stmt: assign_stmt .

    $default  reduce using rule 8 (stmt)


state 37

    9 stmt: while_stmt .

    $default  reduce using rule 9 (stmt)


state 38

   10 stmt: if_stmt .

    $default  reduce using rule 10 (stmt)


state 39

   11 stmt: repeat_until_stmt .

    $default  reduce using rule 11 (stmt)


state 40

   12 stmt: for_stmt .

    $default  reduce using rule 12 (stmt)


state 41

   13 stmt: switch_stmt .

    $default  reduce using rule 13 (stmt)


state 42

   67 var_dec_stmt: type . IDENTIFIER SEMICOLON
   68             | type . IDENTIFIER ASSIGN value SEMICOLON
  126 function_prototype: type . IDENTIFIER LPAREN $@26 params RPAREN
  128                   | type . IDENTIFIER LPAREN $@27 RPAREN

    IDENTIFIER  shift, and go to state 86


state 43

   14 stmt: function .

    $default  reduce using rule 14 (stmt)


state 44

  118 function: function_prototype . LBRACE stmts ret_stmt RBRACE

    LBRACE  shift, and go to state 87


state 45

   55 function_call: IDENTIFIER LPAREN . $@2 RPAREN
   57              | IDENTIFIER LPAREN . $@3 call_params RPAREN

    RPAREN    reduce using rule 54 ($@2)
    $default  reduce using rule 56 ($@3)

    $@2  go to state 88
    $@3  go to state 89


state 46

   69 assign_stmt: IDENTIFIER ASSIGN . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 92
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 47

   70 assign_stmt: IDENTIFIER DIV_EQ . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 94
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 48

   72 assign_stmt: IDENTIFIER PLUS_EQ . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 95
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 49

   73 assign_stmt: IDENTIFIER MINUS_EQ . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 96
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 50

   71 assign_stmt: IDENTIFIER MULT_EQ . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 97
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 51

   36 unary_expr: IDENTIFIER INC .

    $default  reduce using rule 36 (unary_expr)


state 52

   37 unary_expr: IDENTIFIER DEC .

    $default  reduce using rule 37 (unary_expr)


state 53

   66 const_dec_stmt: CONST type . IDENTIFIER ASSIGN constant SEMICOLON

    IDENTIFIER  shift, and go to state 98


state 54

    5 stmt: LBRACE $@1 . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 99
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 55

   36 unary_expr: IDENTIFIER . INC
   37           | IDENTIFIER . DEC
   53 factor: IDENTIFIER .
   55 function_call: IDENTIFIER . LPAREN $@2 RPAREN
   57              | IDENTIFIER . LPAREN $@3 call_params RPAREN

    LPAREN  shift, and go to state 45
    INC     shift, and go to state 51
    DEC     shift, and go to state 52

    $default  reduce using rule 53 (factor)


state 56

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr

    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79


state 57

   20 expr: bool_expr .
   31 bool_expr: LPAREN bool_expr . RPAREN

    RPAREN  shift, and go to state 100

    $default  reduce using rule 20 (expr)


state 58

   34 arithmetic_expr: binary_expr .
   39 binary_expr: binary_expr . PLUS term
   40            | binary_expr . MINUS term
   48 para: LPAREN binary_expr . RPAREN

    RPAREN  shift, and go to state 101
    MINUS   shift, and go to state 80
    PLUS    shift, and go to state 81

    $default  reduce using rule 34 (arithmetic_expr)


state 59

   77 while_stmt: WHILE LPAREN . $@4 bool_expr $@5 RPAREN LBRACE $@6 stmts RBRACE

    $default  reduce using rule 74 ($@4)

    $@4  go to state 102


state 60

   91 for_stmt: FOR $@15 . for_expression_stmt

    LPAREN  shift, and go to state 103

    for_expression_stmt  go to state 104


state 61

  100 switch_stmt: SWITCH LPAREN . expr $@20 RPAREN LBRACE $@21 case_stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 105
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 62

   80 if_stmt: IF LPAREN . expr $@7 RPAREN LBRACE $@8 stmts RBRACE if_body

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 106
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 63

   89 repeat_until_stmt: REPEAT LBRACE . $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    $default  reduce using rule 86 ($@12)

    $@12  go to state 107


state 64

   53 factor: IDENTIFIER .
   55 function_call: IDENTIFIER . LPAREN $@2 RPAREN
   57              | IDENTIFIER . LPAREN $@3 call_params RPAREN

    LPAREN  shift, and go to state 45

    $default  reduce using rule 53 (factor)


state 65

   48 para: LPAREN . binary_expr RPAREN

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    binary_expr    go to state 108
    term           go to state 29
    negat          go to state 30
    para           go to state 31
    factor         go to state 32
    function_call  go to state 33


state 66

   46 negat: MINUS para .
   49 para: para . EXP para

    EXP  shift, and go to state 85

    $default  reduce using rule 46 (negat)


state 67

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
   30          | NOT expr .

    $default  reduce using rule 30 (bool_expr)


state 68

  122 function_prototype: VOID IDENTIFIER . LPAREN $@24 params RPAREN
  124                   | VOID IDENTIFIER . LPAREN $@25 RPAREN

    LPAREN  shift, and go to state 109


state 69

    0 $accept: stmts $end .

    $default  accept


state 70

    1 stmts: stmts stmt .

    $default  reduce using rule 1 (stmts)


state 71

    3 stmt: expr SEMICOLON .

    $default  reduce using rule 3 (stmt)


state 72

   27 bool_expr: expr LE . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 110
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 73

   26 bool_expr: expr GE . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 111
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 74

   23 bool_expr: expr NE . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 112
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 75

   22 bool_expr: expr EQUAL . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 113
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 76

   25 bool_expr: expr LESS . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 114
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 77

   24 bool_expr: expr GREATER . arithmetic_expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    arithmetic_expr  go to state 115
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 78

   29 bool_expr: expr OR . expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 116
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 79

   28 bool_expr: expr AND . expr

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 117
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 80

   40 binary_expr: binary_expr MINUS . term

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    term           go to state 118
    negat          go to state 30
    para           go to state 31
    factor         go to state 32
    function_call  go to state 33


state 81

   39 binary_expr: binary_expr PLUS . term

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65
    MINUS       shift, and go to state 19

    term           go to state 119
    negat          go to state 30
    para           go to state 31
    factor         go to state 32
    function_call  go to state 33


state 82

   44 term: term MOD . factor

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8

    factor         go to state 120
    function_call  go to state 33


state 83

   43 term: term DIV . factor

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8

    factor         go to state 121
    function_call  go to state 33


state 84

   42 term: term MULT . factor

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8

    factor         go to state 122
    function_call  go to state 33


state 85

   49 para: para EXP . para

    IDENTIFIER  shift, and go to state 64
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    LPAREN      shift, and go to state 65

    para           go to state 123
    factor         go to state 32
    function_call  go to state 33


state 86

   67 var_dec_stmt: type IDENTIFIER . SEMICOLON
   68             | type IDENTIFIER . ASSIGN value SEMICOLON
  126 function_prototype: type IDENTIFIER . LPAREN $@26 params RPAREN
  128                   | type IDENTIFIER . LPAREN $@27 RPAREN

    SEMICOLON  shift, and go to state 124
    LPAREN     shift, and go to state 125
    ASSIGN     shift, and go to state 126


state 87

  118 function: function_prototype LBRACE . stmts ret_stmt RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 127
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 88

   55 function_call: IDENTIFIER LPAREN $@2 . RPAREN

    RPAREN  shift, and go to state 128


state 89

   57 function_call: IDENTIFIER LPAREN $@3 . call_params RPAREN

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 129
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33
    call_params      go to state 130


state 90

   19 value: CHAR_VAL .

    $default  reduce using rule 19 (value)


state 91

   18 value: STRING_VAL .

    $default  reduce using rule 18 (value)


state 92

   69 assign_stmt: IDENTIFIER ASSIGN value . SEMICOLON

    SEMICOLON  shift, and go to state 131


state 93

   17 value: expr .
   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr

    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79

    $default  reduce using rule 17 (value)


state 94

   70 assign_stmt: IDENTIFIER DIV_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 132


state 95

   72 assign_stmt: IDENTIFIER PLUS_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 133


state 96

   73 assign_stmt: IDENTIFIER MINUS_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 134


state 97

   71 assign_stmt: IDENTIFIER MULT_EQ value . SEMICOLON

    SEMICOLON  shift, and go to state 135


state 98

   66 const_dec_stmt: CONST type IDENTIFIER . ASSIGN constant SEMICOLON

    ASSIGN  shift, and go to state 136


state 99

    1 stmts: stmts . stmt
    5 stmt: LBRACE $@1 stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 137
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 100

   31 bool_expr: LPAREN bool_expr RPAREN .

    $default  reduce using rule 31 (bool_expr)


state 101

   48 para: LPAREN binary_expr RPAREN .

    $default  reduce using rule 48 (para)


state 102

   77 while_stmt: WHILE LPAREN $@4 . bool_expr $@5 RPAREN LBRACE $@6 stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 56
    bool_expr        go to state 138
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 103

   94 for_expression_stmt: LPAREN . var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE
   97                    | LPAREN . assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 139

    var_dec_stmt  go to state 140
    assign_stmt   go to state 141
    type          go to state 142


state 104

   91 for_stmt: FOR $@15 for_expression_stmt .

    $default  reduce using rule 91 (for_stmt)


state 105

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
  100 switch_stmt: SWITCH LPAREN expr . $@20 RPAREN LBRACE $@21 case_stmts RBRACE

    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79

    $default  reduce using rule 98 ($@20)

    $@20  go to state 143


state 106

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
   80 if_stmt: IF LPAREN expr . $@7 RPAREN LBRACE $@8 stmts RBRACE if_body

    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79

    $default  reduce using rule 78 ($@7)

    $@7  go to state 144


state 107

   89 repeat_until_stmt: REPEAT LBRACE $@12 . stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 145
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 108

   39 binary_expr: binary_expr . PLUS term
   40            | binary_expr . MINUS term
   48 para: LPAREN binary_expr . RPAREN

    RPAREN  shift, and go to state 101
    MINUS   shift, and go to state 80
    PLUS    shift, and go to state 81


state 109

  122 function_prototype: VOID IDENTIFIER LPAREN . $@24 params RPAREN
  124                   | VOID IDENTIFIER LPAREN . $@25 RPAREN

    RPAREN    reduce using rule 123 ($@25)
    $default  reduce using rule 121 ($@24)

    $@24  go to state 146
    $@25  go to state 147


state 110

   27 bool_expr: expr LE arithmetic_expr .

    $default  reduce using rule 27 (bool_expr)


state 111

   26 bool_expr: expr GE arithmetic_expr .

    $default  reduce using rule 26 (bool_expr)


state 112

   23 bool_expr: expr NE arithmetic_expr .

    $default  reduce using rule 23 (bool_expr)


state 113

   22 bool_expr: expr EQUAL arithmetic_expr .

    $default  reduce using rule 22 (bool_expr)


state 114

   25 bool_expr: expr LESS arithmetic_expr .

    $default  reduce using rule 25 (bool_expr)


state 115

   24 bool_expr: expr GREATER arithmetic_expr .

    $default  reduce using rule 24 (bool_expr)


state 116

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
   29          | expr OR expr .

    $default  reduce using rule 29 (bool_expr)


state 117

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   28          | expr AND expr .
   29          | expr . OR expr

    $default  reduce using rule 28 (bool_expr)


state 118

   40 binary_expr: binary_expr MINUS term .
   42 term: term . MULT factor
   43     | term . DIV factor
   44     | term . MOD factor

    MOD   shift, and go to state 82
    DIV   shift, and go to state 83
    MULT  shift, and go to state 84

    $default  reduce using rule 40 (binary_expr)


state 119

   39 binary_expr: binary_expr PLUS term .
   42 term: term . MULT factor
   43     | term . DIV factor
   44     | term . MOD factor

    MOD   shift, and go to state 82
    DIV   shift, and go to state 83
    MULT  shift, and go to state 84

    $default  reduce using rule 39 (binary_expr)


state 120

   44 term: term MOD factor .

    $default  reduce using rule 44 (term)


state 121

   43 term: term DIV factor .

    $default  reduce using rule 43 (term)


state 122

   42 term: term MULT factor .

    $default  reduce using rule 42 (term)


state 123

   49 para: para . EXP para
   49     | para EXP para .

    $default  reduce using rule 49 (para)


state 124

   67 var_dec_stmt: type IDENTIFIER SEMICOLON .

    $default  reduce using rule 67 (var_dec_stmt)


state 125

  126 function_prototype: type IDENTIFIER LPAREN . $@26 params RPAREN
  128                   | type IDENTIFIER LPAREN . $@27 RPAREN

    RPAREN    reduce using rule 127 ($@27)
    $default  reduce using rule 125 ($@26)

    $@26  go to state 148
    $@27  go to state 149


state 126

   68 var_dec_stmt: type IDENTIFIER ASSIGN . value SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 150
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 127

    1 stmts: stmts . stmt
  118 function: function_prototype LBRACE stmts . ret_stmt RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21
    RETURN      shift, and go to state 151

    $default  reduce using rule 120 (ret_stmt)

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    ret_stmt            go to state 152
    function_prototype  go to state 44


state 128

   55 function_call: IDENTIFIER LPAREN $@2 RPAREN .

    $default  reduce using rule 55 (function_call)


state 129

   59 call_params: value .

    $default  reduce using rule 59 (call_params)


state 130

   57 function_call: IDENTIFIER LPAREN $@3 call_params . RPAREN
   58 call_params: call_params . COMMA value

    COMMA   shift, and go to state 153
    RPAREN  shift, and go to state 154


state 131

   69 assign_stmt: IDENTIFIER ASSIGN value SEMICOLON .

    $default  reduce using rule 69 (assign_stmt)


state 132

   70 assign_stmt: IDENTIFIER DIV_EQ value SEMICOLON .

    $default  reduce using rule 70 (assign_stmt)


state 133

   72 assign_stmt: IDENTIFIER PLUS_EQ value SEMICOLON .

    $default  reduce using rule 72 (assign_stmt)


state 134

   73 assign_stmt: IDENTIFIER MINUS_EQ value SEMICOLON .

    $default  reduce using rule 73 (assign_stmt)


state 135

   71 assign_stmt: IDENTIFIER MULT_EQ value SEMICOLON .

    $default  reduce using rule 71 (assign_stmt)


state 136

   66 const_dec_stmt: CONST type IDENTIFIER ASSIGN . constant SEMICOLON

    INT_VAL     shift, and go to state 155
    FLOAT_VAL   shift, and go to state 156
    CHAR_VAL    shift, and go to state 157
    STRING_VAL  shift, and go to state 158
    TRUE_VAL    shift, and go to state 159
    FALSE_VAL   shift, and go to state 160

    constant  go to state 161


state 137

    5 stmt: LBRACE $@1 stmts RBRACE .

    $default  reduce using rule 5 (stmt)


state 138

   20 expr: bool_expr .
   77 while_stmt: WHILE LPAREN $@4 bool_expr . $@5 RPAREN LBRACE $@6 stmts RBRACE

    RPAREN    reduce using rule 75 ($@5)
    $default  reduce using rule 20 (expr)

    $@5  go to state 162


state 139

   69 assign_stmt: IDENTIFIER . ASSIGN value SEMICOLON
   70            | IDENTIFIER . DIV_EQ value SEMICOLON
   71            | IDENTIFIER . MULT_EQ value SEMICOLON
   72            | IDENTIFIER . PLUS_EQ value SEMICOLON
   73            | IDENTIFIER . MINUS_EQ value SEMICOLON

    ASSIGN    shift, and go to state 46
    DIV_EQ    shift, and go to state 47
    PLUS_EQ   shift, and go to state 48
    MINUS_EQ  shift, and go to state 49
    MULT_EQ   shift, and go to state 50


state 140

   94 for_expression_stmt: LPAREN var_dec_stmt . $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    $default  reduce using rule 92 ($@16)

    $@16  go to state 163


state 141

   97 for_expression_stmt: LPAREN assign_stmt . $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    $default  reduce using rule 95 ($@18)

    $@18  go to state 164


state 142

   67 var_dec_stmt: type . IDENTIFIER SEMICOLON
   68             | type . IDENTIFIER ASSIGN value SEMICOLON

    IDENTIFIER  shift, and go to state 165


state 143

  100 switch_stmt: SWITCH LPAREN expr $@20 . RPAREN LBRACE $@21 case_stmts RBRACE

    RPAREN  shift, and go to state 166


state 144

   80 if_stmt: IF LPAREN expr $@7 . RPAREN LBRACE $@8 stmts RBRACE if_body

    RPAREN  shift, and go to state 167


state 145

    1 stmts: stmts . stmt
   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts . RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 168
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 146

  122 function_prototype: VOID IDENTIFIER LPAREN $@24 . params RPAREN

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type    go to state 169
    params  go to state 170
    param   go to state 171


state 147

  124 function_prototype: VOID IDENTIFIER LPAREN $@25 . RPAREN

    RPAREN  shift, and go to state 172


state 148

  126 function_prototype: type IDENTIFIER LPAREN $@26 . params RPAREN

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type    go to state 169
    params  go to state 173
    param   go to state 171


state 149

  128 function_prototype: type IDENTIFIER LPAREN $@27 . RPAREN

    RPAREN  shift, and go to state 174


state 150

   68 var_dec_stmt: type IDENTIFIER ASSIGN value . SEMICOLON

    SEMICOLON  shift, and go to state 175


state 151

  119 ret_stmt: RETURN . ret_val SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    $default  reduce using rule 16 (ret_val)

    ret_val          go to state 176
    value            go to state 177
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 152

  118 function: function_prototype LBRACE stmts ret_stmt . RBRACE

    RBRACE  shift, and go to state 178


state 153

   58 call_params: call_params COMMA . value

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    CHAR_VAL    shift, and go to state 90
    STRING_VAL  shift, and go to state 91
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    value            go to state 179
    expr             go to state 93
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 154

   57 function_call: IDENTIFIER LPAREN $@3 call_params RPAREN .

    $default  reduce using rule 57 (function_call)


state 155

   60 constant: INT_VAL .

    $default  reduce using rule 60 (constant)


state 156

   61 constant: FLOAT_VAL .

    $default  reduce using rule 61 (constant)


state 157

   63 constant: CHAR_VAL .

    $default  reduce using rule 63 (constant)


state 158

   62 constant: STRING_VAL .

    $default  reduce using rule 62 (constant)


state 159

   64 constant: TRUE_VAL .

    $default  reduce using rule 64 (constant)


state 160

   65 constant: FALSE_VAL .

    $default  reduce using rule 65 (constant)


state 161

   66 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant . SEMICOLON

    SEMICOLON  shift, and go to state 180


state 162

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 . RPAREN LBRACE $@6 stmts RBRACE

    RPAREN  shift, and go to state 181


state 163

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 . bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 56
    bool_expr        go to state 182
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 164

   97 for_expression_stmt: LPAREN assign_stmt $@18 . bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 56
    bool_expr        go to state 183
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 165

   67 var_dec_stmt: type IDENTIFIER . SEMICOLON
   68             | type IDENTIFIER . ASSIGN value SEMICOLON

    SEMICOLON  shift, and go to state 124
    ASSIGN     shift, and go to state 126


state 166

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN . LBRACE $@21 case_stmts RBRACE

    LBRACE  shift, and go to state 184


state 167

   80 if_stmt: IF LPAREN expr $@7 RPAREN . LBRACE $@8 stmts RBRACE if_body

    LBRACE  shift, and go to state 185


state 168

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE . $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    $default  reduce using rule 87 ($@13)

    $@13  go to state 186


state 169

  131 param: type . IDENTIFIER
  132      | type . IDENTIFIER ASSIGN constant

    IDENTIFIER  shift, and go to state 187


state 170

  122 function_prototype: VOID IDENTIFIER LPAREN $@24 params . RPAREN
  130 params: params . COMMA param

    COMMA   shift, and go to state 188
    RPAREN  shift, and go to state 189


state 171

  129 params: param .

    $default  reduce using rule 129 (params)


state 172

  124 function_prototype: VOID IDENTIFIER LPAREN $@25 RPAREN .

    $default  reduce using rule 124 (function_prototype)


state 173

  126 function_prototype: type IDENTIFIER LPAREN $@26 params . RPAREN
  130 params: params . COMMA param

    COMMA   shift, and go to state 188
    RPAREN  shift, and go to state 190


state 174

  128 function_prototype: type IDENTIFIER LPAREN $@27 RPAREN .

    $default  reduce using rule 128 (function_prototype)


state 175

   68 var_dec_stmt: type IDENTIFIER ASSIGN value SEMICOLON .

    $default  reduce using rule 68 (var_dec_stmt)


state 176

  119 ret_stmt: RETURN ret_val . SEMICOLON

    SEMICOLON  shift, and go to state 191


state 177

   15 ret_val: value .

    $default  reduce using rule 15 (ret_val)


state 178

  118 function: function_prototype LBRACE stmts ret_stmt RBRACE .

    $default  reduce using rule 118 (function)


state 179

   58 call_params: call_params COMMA value .

    $default  reduce using rule 58 (call_params)


state 180

   66 const_dec_stmt: CONST type IDENTIFIER ASSIGN constant SEMICOLON .

    $default  reduce using rule 66 (const_dec_stmt)


state 181

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN . LBRACE $@6 stmts RBRACE

    LBRACE  shift, and go to state 192


state 182

   20 expr: bool_expr .
   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr . $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  reduce using rule 93 ($@17)
    $default   reduce using rule 20 (expr)

    $@17  go to state 193


state 183

   20 expr: bool_expr .
   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr . $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  reduce using rule 96 ($@19)
    $default   reduce using rule 20 (expr)

    $@19  go to state 194


state 184

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN LBRACE . $@21 case_stmts RBRACE

    $default  reduce using rule 99 ($@21)

    $@21  go to state 195


state 185

   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE . $@8 stmts RBRACE if_body

    $default  reduce using rule 79 ($@8)

    $@8  go to state 196


state 186

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 . UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON

    UNTIL  shift, and go to state 197


state 187

  131 param: type IDENTIFIER .
  132      | type IDENTIFIER . ASSIGN constant

    ASSIGN  shift, and go to state 198

    $default  reduce using rule 131 (param)


state 188

  130 params: params COMMA . param

    INT     shift, and go to state 1
    FLOAT   shift, and go to state 2
    CHAR    shift, and go to state 3
    BOOL    shift, and go to state 4
    STRING  shift, and go to state 5

    type   go to state 169
    param  go to state 199


state 189

  122 function_prototype: VOID IDENTIFIER LPAREN $@24 params RPAREN .

    $default  reduce using rule 122 (function_prototype)


state 190

  126 function_prototype: type IDENTIFIER LPAREN $@26 params RPAREN .

    $default  reduce using rule 126 (function_prototype)


state 191

  119 ret_stmt: RETURN ret_val SEMICOLON .

    $default  reduce using rule 119 (ret_stmt)


state 192

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN LBRACE . $@6 stmts RBRACE

    $default  reduce using rule 76 ($@6)

    $@6  go to state 200


state 193

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 . SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  shift, and go to state 201


state 194

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 . SEMICOLON expr RPAREN LBRACE stmts RBRACE

    SEMICOLON  shift, and go to state 202


state 195

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN LBRACE $@21 . case_stmts RBRACE

    CASE     shift, and go to state 203
    DEFAULT  shift, and go to state 204

    case_stmts  go to state 205
    case_stmt   go to state 206


state 196

   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE $@8 . stmts RBRACE if_body

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 207
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 197

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL . LPAREN bool_expr $@14 RPAREN SEMICOLON

    LPAREN  shift, and go to state 208


state 198

  132 param: type IDENTIFIER ASSIGN . constant

    INT_VAL     shift, and go to state 155
    FLOAT_VAL   shift, and go to state 156
    CHAR_VAL    shift, and go to state 157
    STRING_VAL  shift, and go to state 158
    TRUE_VAL    shift, and go to state 159
    FALSE_VAL   shift, and go to state 160

    constant  go to state 209


state 199

  130 params: params COMMA param .

    $default  reduce using rule 130 (params)


state 200

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN LBRACE $@6 . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 210
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 201

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON . expr RPAREN LBRACE stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 211
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 202

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON . expr RPAREN LBRACE stmts RBRACE

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 212
    bool_expr        go to state 25
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 203

  104 case_stmt: CASE . constant COLON $@22 case_in_scope_stmts case_end

    INT_VAL     shift, and go to state 155
    FLOAT_VAL   shift, and go to state 156
    CHAR_VAL    shift, and go to state 157
    STRING_VAL  shift, and go to state 158
    TRUE_VAL    shift, and go to state 159
    FALSE_VAL   shift, and go to state 160

    constant  go to state 213


state 204

  106 case_stmt: DEFAULT . COLON $@23 case_in_scope_stmts default_case_end

    COLON  shift, and go to state 214


state 205

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN LBRACE $@21 case_stmts . RBRACE
  101 case_stmts: case_stmts . case_stmt

    RBRACE   shift, and go to state 215
    CASE     shift, and go to state 203
    DEFAULT  shift, and go to state 204

    case_stmt  go to state 216


state 206

  102 case_stmts: case_stmt .

    $default  reduce using rule 102 (case_stmts)


state 207

    1 stmts: stmts . stmt
   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE $@8 stmts . RBRACE if_body

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 217
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 208

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN . bool_expr $@14 RPAREN SEMICOLON

    IDENTIFIER  shift, and go to state 55
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    LPAREN      shift, and go to state 13
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20

    expr             go to state 56
    bool_expr        go to state 218
    arithmetic_expr  go to state 26
    unary_expr       go to state 27
    binary_expr      go to state 28
    term             go to state 29
    negat            go to state 30
    para             go to state 31
    factor           go to state 32
    function_call    go to state 33


state 209

  132 param: type IDENTIFIER ASSIGN constant .

    $default  reduce using rule 132 (param)


state 210

    1 stmts: stmts . stmt
   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN LBRACE $@6 stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 219
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 211

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr . RPAREN LBRACE stmts RBRACE

    RPAREN   shift, and go to state 220
    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79


state 212

   22 bool_expr: expr . EQUAL arithmetic_expr
   23          | expr . NE arithmetic_expr
   24          | expr . GREATER arithmetic_expr
   25          | expr . LESS arithmetic_expr
   26          | expr . GE arithmetic_expr
   27          | expr . LE arithmetic_expr
   28          | expr . AND expr
   29          | expr . OR expr
   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr . RPAREN LBRACE stmts RBRACE

    RPAREN   shift, and go to state 221
    LE       shift, and go to state 72
    GE       shift, and go to state 73
    NE       shift, and go to state 74
    EQUAL    shift, and go to state 75
    LESS     shift, and go to state 76
    GREATER  shift, and go to state 77
    OR       shift, and go to state 78
    AND      shift, and go to state 79


state 213

  104 case_stmt: CASE constant . COLON $@22 case_in_scope_stmts case_end

    COLON  shift, and go to state 222


state 214

  106 case_stmt: DEFAULT COLON . $@23 case_in_scope_stmts default_case_end

    $default  reduce using rule 105 ($@23)

    $@23  go to state 223


state 215

  100 switch_stmt: SWITCH LPAREN expr $@20 RPAREN LBRACE $@21 case_stmts RBRACE .

    $default  reduce using rule 100 (switch_stmt)


state 216

  101 case_stmts: case_stmts case_stmt .

    $default  reduce using rule 101 (case_stmts)


state 217

   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE $@8 stmts RBRACE . if_body

    ELSE      reduce using rule 81 ($@9)
    $default  reduce using rule 85 (if_body)

    if_body  go to state 224
    $@9      go to state 225


state 218

   20 expr: bool_expr .
   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr . $@14 RPAREN SEMICOLON

    RPAREN    reduce using rule 88 ($@14)
    $default  reduce using rule 20 (expr)

    $@14  go to state 226


state 219

   77 while_stmt: WHILE LPAREN $@4 bool_expr $@5 RPAREN LBRACE $@6 stmts RBRACE .

    $default  reduce using rule 77 (while_stmt)


state 220

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 227


state 221

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN . LBRACE stmts RBRACE

    LBRACE  shift, and go to state 228


state 222

  104 case_stmt: CASE constant COLON . $@22 case_in_scope_stmts case_end

    $default  reduce using rule 103 ($@22)

    $@22  go to state 229


state 223

  106 case_stmt: DEFAULT COLON $@23 . case_in_scope_stmts default_case_end

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    $default  reduce using rule 108 (case_in_scope_stmts)

    stmts                go to state 230
    stmt                 go to state 23
    expr                 go to state 24
    bool_expr            go to state 25
    arithmetic_expr      go to state 26
    unary_expr           go to state 27
    binary_expr          go to state 28
    term                 go to state 29
    negat                go to state 30
    para                 go to state 31
    factor               go to state 32
    function_call        go to state 33
    const_dec_stmt       go to state 34
    var_dec_stmt         go to state 35
    assign_stmt          go to state 36
    while_stmt           go to state 37
    if_stmt              go to state 38
    repeat_until_stmt    go to state 39
    for_stmt             go to state 40
    switch_stmt          go to state 41
    case_in_scope_stmts  go to state 231
    type                 go to state 42
    function             go to state 43
    function_prototype   go to state 44


state 224

   80 if_stmt: IF LPAREN expr $@7 RPAREN LBRACE $@8 stmts RBRACE if_body .

    $default  reduce using rule 80 (if_stmt)


state 225

   84 if_body: $@9 . ELSE $@10 LBRACE $@11 stmts RBRACE

    ELSE  shift, and go to state 232


state 226

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 . RPAREN SEMICOLON

    RPAREN  shift, and go to state 233


state 227

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 234
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 228

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 235
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 229

  104 case_stmt: CASE constant COLON $@22 . case_in_scope_stmts case_end

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    $default  reduce using rule 108 (case_in_scope_stmts)

    stmts                go to state 230
    stmt                 go to state 23
    expr                 go to state 24
    bool_expr            go to state 25
    arithmetic_expr      go to state 26
    unary_expr           go to state 27
    binary_expr          go to state 28
    term                 go to state 29
    negat                go to state 30
    para                 go to state 31
    factor               go to state 32
    function_call        go to state 33
    const_dec_stmt       go to state 34
    var_dec_stmt         go to state 35
    assign_stmt          go to state 36
    while_stmt           go to state 37
    if_stmt              go to state 38
    repeat_until_stmt    go to state 39
    for_stmt             go to state 40
    switch_stmt          go to state 41
    case_in_scope_stmts  go to state 236
    type                 go to state 42
    function             go to state 43
    function_prototype   go to state 44


state 230

    1 stmts: stmts . stmt
  107 case_in_scope_stmts: stmts .

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    $default  reduce using rule 107 (case_in_scope_stmts)

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 231

  106 case_stmt: DEFAULT COLON $@23 case_in_scope_stmts . default_case_end

    BREAK  shift, and go to state 237

    $default  reduce using rule 112 (default_case_end)

    default_case_end  go to state 238


state 232

   84 if_body: $@9 ELSE . $@10 LBRACE $@11 stmts RBRACE

    $default  reduce using rule 82 ($@10)

    $@10  go to state 239


state 233

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN . SEMICOLON

    SEMICOLON  shift, and go to state 240


state 234

    1 stmts: stmts . stmt
   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 241
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 235

    1 stmts: stmts . stmt
   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 242
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 236

  104 case_stmt: CASE constant COLON $@22 case_in_scope_stmts . case_end

    BREAK  shift, and go to state 243

    $default  reduce using rule 110 (case_end)

    case_end  go to state 244


state 237

  111 default_case_end: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 245


state 238

  106 case_stmt: DEFAULT COLON $@23 case_in_scope_stmts default_case_end .

    $default  reduce using rule 106 (case_stmt)


state 239

   84 if_body: $@9 ELSE $@10 . LBRACE $@11 stmts RBRACE

    LBRACE  shift, and go to state 246


state 240

   89 repeat_until_stmt: REPEAT LBRACE $@12 stmts RBRACE $@13 UNTIL LPAREN bool_expr $@14 RPAREN SEMICOLON .

    $default  reduce using rule 89 (repeat_until_stmt)


state 241

   94 for_expression_stmt: LPAREN var_dec_stmt $@16 bool_expr $@17 SEMICOLON expr RPAREN LBRACE stmts RBRACE .

    $default  reduce using rule 94 (for_expression_stmt)


state 242

   97 for_expression_stmt: LPAREN assign_stmt $@18 bool_expr $@19 SEMICOLON expr RPAREN LBRACE stmts RBRACE .

    $default  reduce using rule 97 (for_expression_stmt)


state 243

  109 case_end: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 247


state 244

  104 case_stmt: CASE constant COLON $@22 case_in_scope_stmts case_end .

    $default  reduce using rule 104 (case_stmt)


state 245

  111 default_case_end: BREAK SEMICOLON .

    $default  reduce using rule 111 (default_case_end)


state 246

   84 if_body: $@9 ELSE $@10 LBRACE . $@11 stmts RBRACE

    $default  reduce using rule 83 ($@11)

    $@11  go to state 248


state 247

  109 case_end: BREAK SEMICOLON .

    $default  reduce using rule 109 (case_end)


state 248

   84 if_body: $@9 ELSE $@10 LBRACE $@11 . stmts RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmts               go to state 249
    stmt                go to state 23
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 249

    1 stmts: stmts . stmt
   84 if_body: $@9 ELSE $@10 LBRACE $@11 stmts . RBRACE

    INT         shift, and go to state 1
    FLOAT       shift, and go to state 2
    CHAR        shift, and go to state 3
    BOOL        shift, and go to state 4
    STRING      shift, and go to state 5
    IDENTIFIER  shift, and go to state 6
    INT_VAL     shift, and go to state 7
    FLOAT_VAL   shift, and go to state 8
    TRUE_VAL    shift, and go to state 9
    FALSE_VAL   shift, and go to state 10
    CONST       shift, and go to state 11
    LBRACE      shift, and go to state 12
    RBRACE      shift, and go to state 250
    LPAREN      shift, and go to state 13
    WHILE       shift, and go to state 14
    FOR         shift, and go to state 15
    SWITCH      shift, and go to state 16
    IF          shift, and go to state 17
    REPEAT      shift, and go to state 18
    MINUS       shift, and go to state 19
    NOT         shift, and go to state 20
    VOID        shift, and go to state 21

    stmt                go to state 70
    expr                go to state 24
    bool_expr           go to state 25
    arithmetic_expr     go to state 26
    unary_expr          go to state 27
    binary_expr         go to state 28
    term                go to state 29
    negat               go to state 30
    para                go to state 31
    factor              go to state 32
    function_call       go to state 33
    const_dec_stmt      go to state 34
    var_dec_stmt        go to state 35
    assign_stmt         go to state 36
    while_stmt          go to state 37
    if_stmt             go to state 38
    repeat_until_stmt   go to state 39
    for_stmt            go to state 40
    switch_stmt         go to state 41
    type                go to state 42
    function            go to state 43
    function_prototype  go to state 44


state 250

   84 if_body: $@9 ELSE $@10 LBRACE $@11 stmts RBRACE .

    $default  reduce using rule 84 (if_body)
